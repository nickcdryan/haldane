<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haldane - Automated Program Discovery for AI Systems</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --black: #000000;
            --white: #ffffff;
            --gray-1: #fafafa;
            --gray-2: #f0f0f0;
            --gray-3: #888888;
            --gray-4: #555555;
            
            /* Vibrant Kandinsky/Miro colors */
            --k-red: #FF1744;
            --k-blue: #2979FF;
            --k-yellow: #FFD600;
            --k-purple: #AA00FF;
            --k-green: #00E676;
            --k-orange: #FF6D00;
            --k-pink: #F50057;
            --k-cyan: #00E5FF;
            --k-lime: #C6FF00;
            --k-indigo: #3D5AFE;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            background: var(--white);
            color: var(--black);
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* Main Kandinsky/Miro background layer */
        .art-bg {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            overflow: hidden;
        }

        /* Kandinsky concentric circles */
        .concentric-circles {
            position: absolute;
            top: 15%;
            right: 10%;
            width: 250px;
            height: 250px;
            opacity: 0.3;
        }

        .concentric-circles::before,
        .concentric-circles::after {
            content: '';
            position: absolute;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .concentric-circles::before {
            width: 250px;
            height: 250px;
            border: 4px solid var(--k-blue);
        }

        .concentric-circles::after {
            width: 180px;
            height: 180px;
            background: var(--k-yellow);
            opacity: 0.4;
        }

        .inner-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 3px solid var(--k-red);
            border-radius: 50%;
        }

        /* Miro-style organic blob */
        .miro-blob-1 {
            position: absolute;
            bottom: 20%;
            left: 5%;
            width: 200px;
            height: 180px;
            background: var(--k-green);
            border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%;
            opacity: 0.25;
            animation: morph 20s ease-in-out infinite;
        }

        .miro-blob-2 {
            position: absolute;
            top: 40%;
            left: 30%;
            width: 150px;
            height: 140px;
            background: var(--k-orange);
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
            opacity: 0.2;
            animation: morph 25s ease-in-out infinite reverse;
        }

        @keyframes morph {
            0%, 100% { border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; }
            50% { border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; }
        }

        /* Kandinsky triangular composition */
        .triangle-comp {
            position: absolute;
            top: 60%;
            right: 25%;
            opacity: 0.3;
        }

        .triangle-1 {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 80px solid transparent;
            border-right: 80px solid transparent;
            border-bottom: 140px solid var(--k-purple);
            animation: rotate 30s linear infinite;
        }

        .triangle-2 {
            position: absolute;
            left: 50px;
            top: 30px;
            width: 0;
            height: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            border-bottom: 90px solid var(--k-pink);
            opacity: 0.6;
        }

        /* Miro-style stars */
        .miro-star {
            position: absolute;
            top: 25%;
            left: 15%;
            font-size: 40px;
            color: var(--k-yellow);
            animation: twinkle 3s ease-in-out infinite;
        }

        .miro-star::before {
            content: '✦';
        }

        .miro-star-2 {
            position: absolute;
            bottom: 35%;
            right: 20%;
            font-size: 30px;
            color: var(--k-cyan);
            animation: twinkle 4s ease-in-out infinite;
        }

        .miro-star-2::before {
            content: '★';
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
            50% { opacity: 0.6; transform: scale(1.2) rotate(180deg); }
        }

        /* Kandinsky lines composition */
        .lines-comp {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0.2;
        }

        .k-line-1 {
            position: absolute;
            top: 20%;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--k-red);
            transform: rotate(-15deg);
        }

        .k-line-2 {
            position: absolute;
            top: 45%;
            left: -20%;
            right: -20%;
            height: 4px;
            background: var(--k-blue);
            transform: rotate(25deg);
        }

        .k-line-3 {
            position: absolute;
            top: 70%;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--k-lime);
            transform: rotate(-8deg);
        }

        /* Miro-style dots pattern */
        .miro-dots {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.4;
        }

        .dot-1 {
            position: absolute;
            top: 15%;
            left: 40%;
            width: 20px;
            height: 20px;
            background: var(--k-red);
            border-radius: 50%;
            animation: float 15s ease-in-out infinite;
        }

        .dot-2 {
            position: absolute;
            top: 35%;
            right: 15%;
            width: 15px;
            height: 15px;
            background: var(--k-blue);
            border-radius: 50%;
            animation: float 20s ease-in-out infinite reverse;
        }

        .dot-3 {
            position: absolute;
            bottom: 25%;
            left: 25%;
            width: 25px;
            height: 25px;
            background: var(--k-yellow);
            border-radius: 50%;
            animation: pulse 10s ease-in-out infinite;
        }

        .dot-4 {
            position: absolute;
            top: 55%;
            left: 60%;
            width: 12px;
            height: 12px;
            background: var(--k-green);
            border-radius: 50%;
        }

        .dot-5 {
            position: absolute;
            bottom: 40%;
            right: 35%;
            width: 18px;
            height: 18px;
            background: var(--k-purple);
            border-radius: 50%;
            animation: float 18s ease-in-out infinite;
        }

        /* Kandinsky squares */
        .k-square-1 {
            position: absolute;
            top: 35%;
            left: 8%;
            width: 100px;
            height: 100px;
            background: var(--k-indigo);
            opacity: 0.2;
            transform: rotate(45deg);
            animation: pulse 15s ease-in-out infinite;
        }

        .k-square-2 {
            position: absolute;
            bottom: 15%;
            right: 12%;
            width: 80px;
            height: 80px;
            border: 3px solid var(--k-orange);
            opacity: 0.3;
            transform: rotate(15deg);
            animation: rotate 40s linear infinite reverse;
        }

        /* Miro curved lines */
        .curved-line-1 {
            position: absolute;
            top: 30%;
            left: 20%;
            width: 200px;
            height: 200px;
            border: 3px solid var(--k-pink);
            border-radius: 50%;
            border-bottom-color: transparent;
            border-left-color: transparent;
            opacity: 0.3;
            transform: rotate(45deg);
            animation: rotate 25s linear infinite;
        }

        .curved-line-2 {
            position: absolute;
            bottom: 30%;
            right: 30%;
            width: 150px;
            height: 150px;
            border: 2px solid var(--k-cyan);
            border-radius: 50%;
            border-top-color: transparent;
            border-right-color: transparent;
            opacity: 0.3;
            transform: rotate(-30deg);
        }

        /* Large background circle */
        .bg-circle-large {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 600px;
            border: 2px solid var(--k-lime);
            border-radius: 50%;
            opacity: 0.1;
            animation: pulse 30s ease-in-out infinite;
        }

        /* Eye-like Miro element */
        .miro-eye {
            position: absolute;
            top: 70%;
            left: 40%;
            opacity: 0.25;
        }

        .eye-outer {
            width: 80px;
            height: 50px;
            background: var(--k-blue);
            border-radius: 50%;
            position: relative;
        }

        .eye-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: var(--k-red);
            border-radius: 50%;
        }

        .eye-pupil {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 15px;
            height: 15px;
            background: var(--black);
            border-radius: 50%;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) translateX(0); }
            33% { transform: translateY(-30px) translateX(15px); }
            66% { transform: translateY(15px) translateX(-20px); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1) translate(-50%, -50%); opacity: 0.1; }
            50% { transform: scale(1.1) translate(-45%, -45%); opacity: 0.2; }
        }

        /* Navigation */
        nav {
            position: fixed;
            width: 100%;
            top: 0;
            padding: 2rem 5%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            border-bottom: 1px solid var(--black);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 3px;
            color: var(--black);
            position: relative;
        }

        /* Small colored accent by logo */
        .logo::after {
            content: '';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: var(--k-red);
            border-radius: 50%;
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8rem 5% 4rem;
            position: relative;
            background: rgba(255, 255, 255, 0.9);
        }

        .hero-content {
            max-width: 1400px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4rem;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .hero h1 {
            font-size: 3.5rem;
            font-weight: 300;
            line-height: 1.1;
            margin-bottom: 1.5rem;
            letter-spacing: -1px;
        }

        .hero h1 span {
            display: block;
            font-weight: 700;
            margin-top: 0.5rem;
            position: relative;
        }

        /* Colored underline accent */
        .hero h1 span::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100px;
            height: 3px;
            background: linear-gradient(to right, var(--k-red), var(--k-blue), var(--k-yellow));
        }

        .subtitle {
            font-size: 1.125rem;
            color: var(--gray-4);
            margin-bottom: 2rem;
            line-height: 1.8;
        }

        .code-snippet {
            background: var(--gray-1);
            border: 1px solid var(--black);
            padding: 1.5rem;
            margin-bottom: 2rem;
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            position: relative;
        }

        /* Colored corner accent */
        .code-snippet::after {
            content: '';
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: var(--k-purple);
            opacity: 0.3;
            border-radius: 50%;
        }

        .cta-button {
            display: inline-block;
            padding: 1rem 2.5rem;
            background: var(--black);
            color: var(--white);
            text-decoration: none;
            font-weight: 600;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            border: 2px solid var(--black);
            position: relative;
        }

        .cta-button:hover {
            background: var(--white);
            color: var(--black);
        }

        /* Colored dots around button */
        .cta-button::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            width: 6px;
            height: 6px;
            background: var(--k-red);
            border-radius: 50%;
        }

        .video-container {
            position: relative;
            background: var(--gray-1);
            aspect-ratio: 16/9;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--black);
            overflow: hidden;
        }

        .play-button {
            width: 60px;
            height: 60px;
            background: var(--white);
            border: 2px solid var(--black);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1;
        }

        .play-button:hover {
            background: var(--black);
            color: var(--white);
            transform: scale(1.1);
        }

        .play-button::after {
            content: '▶';
            font-size: 1.2rem;
            margin-left: 3px;
        }

        /* Section Styles */
        section {
            padding: 5rem 5%;
            position: relative;
            background: rgba(255, 255, 255, 0.95);
        }
        .viz-section { padding-top: 2rem; padding-left: 4%; padding-right: 4%; }
        .viz-section .container { margin-left: 0; margin-right: auto; }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .section-label {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 1rem;
            font-weight: 600;
            color: var(--gray-4);
            position: relative;
            display: inline-block;
        }

        /* Colored dot accent */
        .section-label::after {
            content: '';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: var(--k-blue);
            border-radius: 50%;
        }

        .section-title {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 1rem;
            letter-spacing: -1px;
        }

        .section-title strong {
            font-weight: 700;
        }

        .section-description {
            color: var(--gray-4);
            font-size: 1.125rem;
            margin-bottom: 3rem;
            max-width: 800px;
            line-height: 1.8;
        }

        /* Problem Section */
        .problem-section {
            background: rgba(247, 247, 247, 0.95);
            position: relative;
        }

        .problem-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .problem-card {
            background: var(--white);
            padding: 2.5rem 2rem;
            border: 1px solid var(--black);
            transition: all 0.3s ease;
            position: relative;
        }

        .problem-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* Colored corner accent for cards */
        .problem-card::before {
            content: '';
            position: absolute;
            top: -3px;
            right: -3px;
            width: 15px;
            height: 15px;
            background: var(--k-yellow);
            opacity: 0.5;
            border-radius: 50%;
        }

        .problem-card:nth-child(2)::before {
            background: var(--k-green);
        }

        .problem-card:nth-child(3)::before {
            background: var(--k-pink);
        }

        .problem-number {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            line-height: 1;
        }

        .problem-card h3 {
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .problem-card p {
            color: var(--gray-4);
            line-height: 1.7;
        }

        /* Solution Section */
        .how-it-works {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 3rem;
            margin-top: 3rem;
        }

        .process-step {
            position: relative;
            padding-left: 4rem;
        }

        .process-step::before {
            content: attr(data-step);
            position: absolute;
            left: 0;
            top: 0;
            width: 3rem;
            height: 3rem;
            background: var(--black);
            color: var(--white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.25rem;
            border-radius: 50%;
        }

        /* Colored ring around step number */
        .process-step::after {
            content: '';
            position: absolute;
            left: -5px;
            top: -5px;
            width: 4rem;
            height: 4rem;
            border: 2px solid var(--k-blue);
            border-radius: 50%;
            opacity: 0.3;
        }

        .process-step:nth-child(2)::after {
            border-color: var(--k-red);
        }

        .process-step:nth-child(3)::after {
            border-color: var(--k-yellow);
        }

        .process-step h3 {
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .process-step p {
            color: var(--gray-4);
            line-height: 1.7;
        }

        .discovery-visual {
            background: var(--black);
            color: var(--white);
            padding: 3rem;
            margin-top: 3rem;
            position: relative;
            border: 1px solid var(--black);
        }

        /* Big Bet Section */
        .bet-section {
            background: var(--white);
            border: 1px solid var(--black);
            margin: 5rem auto;
            max-width: 900px;
            padding: 3rem;
            position: relative;
        }

        .bet-content {
            font-size: 1.125rem;
            line-height: 1.8;
            color: var(--black);
        }

        .bet-content strong {
            font-weight: 700;
            border-bottom: 2px solid var(--black);
        }

        .bet-signature {
            margin-top: 2rem;
            text-align: center;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-size: 0.875rem;
        }

        /* Results Section */
        .results-section {
            background: rgba(247, 247, 247, 0.95);
            position: relative;
        }

        .case-studies {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-top: 3rem;
        }

        .case-study {
            background: var(--white);
            border: 1px solid var(--black);
            padding: 2rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .case-study:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* Colored accent line */
        .case-study::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--k-purple);
        }

        .case-study:nth-child(2)::after {
            background: var(--k-orange);
        }

        .case-study:nth-child(3)::after {
            background: var(--k-cyan);
        }

        .case-metric {
            font-size: 3rem;
            font-weight: 700;
            line-height: 1;
            margin-bottom: 0.5rem;
        }

        .case-metric-label {
            font-size: 0.875rem;
            color: var(--gray-4);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--gray-2);
        }

        .case-study h4 {
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
        }

        .case-study p {
            color: var(--gray-4);
            line-height: 1.6;
        }

        /* CTA Section */
        .cta-section {
            padding: 6rem 5%;
            text-align: center;
            position: relative;
            background: rgba(255, 255, 255, 0.95);
        }

        .email-form {
            max-width: 500px;
            margin: 2rem auto 0;
            display: flex;
            gap: 0;
            position: relative;
            z-index: 1;
        }

        .email-input {
            flex: 1;
            padding: 1rem 1.5rem;
            background: var(--white);
            border: 1px solid var(--black);
            border-right: none;
            color: var(--black);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .email-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--black);
        }

        .email-input::placeholder {
            color: var(--gray-3);
        }

        .submit-button {
            padding: 1rem 2rem;
            background: var(--black);
            border: 1px solid var(--black);
            color: var(--white);
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .submit-button:hover {
            background: var(--white);
            color: var(--black);
        }

        .success-message {
            display: none;
            color: var(--black);
            margin-top: 1rem;
            font-size: 1rem;
            font-weight: 600;
        }

        /* Stats */
        .stats {
            display: flex;
            justify-content: center;
            gap: 4rem;
            margin-top: 3rem;
            padding-top: 3rem;
            border-top: 1px solid var(--gray-2);
            position: relative;
            z-index: 1;
        }

        .stat {
            text-align: center;
            position: relative;
        }

        /* Colored accent for each stat */
        .stat::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 3px;
            background: var(--k-red);
        }

        .stat:nth-child(2)::before {
            background: var(--k-blue);
        }

        .stat:nth-child(3)::before {
            background: var(--k-yellow);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
        }

        .stat-label {
            color: var(--gray-4);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 0.5rem;
            font-weight: 600;
        }

        /* Footer */
        footer {
            padding: 2rem 5%;
            background: var(--black);
            color: var(--white);
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-size: 0.875rem;
            position: relative;
        }

        /* Colored dots in footer */
        footer::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 20%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            background: var(--k-pink);
            border-radius: 50%;
            box-shadow: 
                30px 0 0 var(--k-cyan),
                60px 0 0 var(--k-lime);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero-content {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .email-form {
                flex-direction: column;
            }

            .email-input {
                border-right: 1px solid var(--black);
                border-bottom: none;
            }

            .stats {
                flex-direction: column;
                gap: 2rem;
            }
        }

        /* Visualization styles (from viz.html) */
        .visualization-container {
            display: flex;
            gap: 3rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.95);
            border: none;
        }

        .canvas-container { position: relative; }
        .canvas-col { display: flex; align-items: flex-start; }

        #treeCanvas {
            border: none;
            background: transparent;
        }

        .diagram-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            height: 150px;
            background: var(--white);
            border: 1px solid var(--black);
            padding: 0.75rem;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        .diagram-overlay.visible { opacity: 1; transform: translateY(0); }

        .diagram-header {
            color: var(--black);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: none;
        }
        .diagram-fitness { color: var(--k-blue); float: right; }
        #diagramCanvas { border: none; background: transparent; }

        .axis-label {
            position: absolute;
            color: var(--gray-4);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .x-axis-label { bottom: -25px; left: 50%; transform: translateX(-50%); }
        .y-axis-label { left: -60px; top: 50%; transform: rotate(-90deg) translateX(-50%); transform-origin: center; }

        .stats-panel {
            width: 280px;
            padding: 1.5rem;
            background: var(--white);
            border: none;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .stat-item { border-bottom: none; padding-bottom: 1rem; }
        .stat-item:last-child { border-bottom: none; }
        .stat-label { font-size: 0.75rem; color: var(--gray-4); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.5rem; }
        .stat-value { font-size: 2rem; color: var(--black); font-weight: 700; }
        .stat-value.secondary { color: var(--k-blue); }
        .stat-value.small { font-size: 1.5rem; }

        .progress-bar { width: 100%; height: 4px; background: var(--gray-2); border-radius: 2px; overflow: hidden; margin-top: 0.5rem; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--k-blue) 0%, var(--k-yellow) 100%); transition: width 0.3s ease; }

        .strategy-indicator { display: flex; gap: 0.5rem; margin-top: 0.5rem; }
        .strategy-bar { flex: 1; height: 20px; background: var(--gray-2); position: relative; overflow: hidden; }
        .strategy-fill { height: 100%; transition: width 0.3s ease; }
        .strategy-bar.explore .strategy-fill { background: var(--k-orange); }
        .strategy-bar.exploit .strategy-fill { background: var(--k-blue); }
        .strategy-label { font-size: 0.65rem; margin-top: 0.25rem; text-align: center; }

        .controls { display: flex; gap: 1rem; margin-top: 1rem; }
        .controls button {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--black);
            border: 2px solid var(--black);
            color: var(--white);
            font-family: inherit;
            font-size: 0.875rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .controls button:hover { background: var(--white); color: var(--black); }
        .controls button:disabled { opacity: 0.5; cursor: not-allowed; }

        .speed-control { margin-top: 1rem; }
        .speed-slider { width: 100%; margin-top: 0.5rem; }

        .legend { margin-top: 1.5rem; padding-top: 1.5rem; border-top: none; }
        .legend-item { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: var(--gray-4); }
        .legend-circle { width: 12px; height: 12px; border-radius: 50%; border: none; }

        .visualization-container .title { text-align: center; margin-bottom: 2rem; }
        .visualization-container .title h2 { font-size: 1.25rem; color: var(--black); margin-bottom: 0.5rem; letter-spacing: 2px; font-weight: 700; }
        .visualization-container .subtitle { color: var(--gray-4); font-size: 0.875rem; }
        /* Allow same title styles when placed above the container */
        .viz-title .title { text-align: center; margin-bottom: 2rem; }
        .viz-title .title h2 { font-size: 1.25rem; color: var(--black); margin-bottom: 0.5rem; letter-spacing: 2px; font-weight: 700; }
        .viz-title .subtitle { color: var(--gray-4); font-size: 0.875rem; }
    </style>
</head>
<body>
    <!-- Kandinsky/Miro artistic background -->
    <div class="art-bg">
        <!-- Kandinsky elements -->
        <div class="concentric-circles">
            <div class="inner-circle"></div>
        </div>
        <div class="triangle-comp">
            <div class="triangle-1"></div>
            <div class="triangle-2"></div>
        </div>
        <div class="k-square-1"></div>
        <div class="k-square-2"></div>
        <div class="bg-circle-large"></div>
        
        <!-- Lines composition -->
        <div class="lines-comp">
            <div class="k-line-1"></div>
            <div class="k-line-2"></div>
            <div class="k-line-3"></div>
        </div>
        
        <!-- Miro elements -->
        <div class="miro-blob-1"></div>
        <div class="miro-blob-2"></div>
        <div class="miro-star"></div>
        <div class="miro-star-2"></div>
        <div class="curved-line-1"></div>
        <div class="curved-line-2"></div>
        
        <!-- Dots pattern -->
        <div class="miro-dots">
            <div class="dot-1"></div>
            <div class="dot-2"></div>
            <div class="dot-3"></div>
            <div class="dot-4"></div>
            <div class="dot-5"></div>
        </div>
        
        <!-- Miro eye -->
        <div class="miro-eye">
            <div class="eye-outer">
                <div class="eye-inner">
                    <div class="eye-pupil"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <div class="logo">HALDANE</div>
            <a href="#cta" class="cta-button">Get Early Access</a>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-content">
            <div class="hero-text">
                <h1>Automated <span>Program Discovery</span> for AI Systems</h1>
                <p class="subtitle">Not another agent builder. We discover them through systematic exploration of program space.</p>
                
                <div class="code-snippet">
                    <code># Your task → Optimal program</code><br>
                    <code>discover(examples) → solution</code>
                </div>
                
                <a href="#cta" class="cta-button">Start Discovery</a>
            </div>
            
            <div class="video-container">
                <div class="play-button"></div>
            </div>
        </div>
    </section>

    <!-- Full Visualization Section (replacing inline preview) -->
    <section class="viz-section">
        <div class="container">

            <div class="visualization-container">
                <div class="canvas-col">
                    <div class="canvas-container">
                        <canvas id="treeCanvas" width="1000" height="700"></canvas>
                        <div class="diagram-overlay" id="diagramOverlay">
                            <div class="diagram-header">
                                BEST PROGRAM <span class="diagram-fitness" id="diagramFitness">0.000</span>
                            </div>
                            <canvas id="diagramCanvas" width="200" height="100"></canvas>
                        </div>

                    </div>
                </div>

                <div class="stats-panel">
                    <div class="stat-item">
                        <div class="stat-label">Iteration</div>
                        <div class="stat-value" id="iterationCount">0</div>
                    </div>
                    
                    
                    
                    <div class="stat-item">
                        <div class="stat-label">Best Fitness</div>
                        <div class="stat-value" id="bestFitness">0.00</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="fitnessBar" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="stat-item">
                        <div class="strategy-indicator">
                            <div>
                                <div class="strategy-bar explore">
                                    <div class="strategy-fill" id="exploreBar"></div>
                                </div>
                                <div class="strategy-label">EXPLORE</div>
                            </div>
                            <div>
                                <div class="strategy-bar exploit">
                                    <div class="strategy-fill" id="exploitBar"></div>
                                </div>
                                <div class="strategy-label">EXPLOIT</div>
                            </div>
                        </div>
                    </div>

                    <div class="controls">
                        <button id="playBtn">PLAY</button>
                        <button id="resetBtn">RESET</button>
                    </div>

                    


                </div>
            </div>
        </div>
    </section>

    <!-- Problem Section -->
    <section class="problem-section">
        <div class="container">
            <span class="section-label">The Problem</span>
            <h2 class="section-title">Why <strong>Hand-Coding</strong> AI Fails</h2>
            <p class="section-description">
                You're spending weeks tweaking prompts, chaining tools, and debugging agent workflows. 
                Meanwhile, your competitors are shipping solutions that actually work.
            </p>
            
            <div class="problem-grid">
                <div class="problem-card">
                    <div class="problem-number">78%</div>
                    <h3>Failure Rate</h3>
                    <p>Most hand-crafted agents fail in production. The problem space is too vast for human intuition alone.</p>
                </div>
                <div class="problem-card">
                    <div class="problem-number">∞</div>
                    <h3>Infinite Complexity</h3>
                    <p>Billions of possible program configurations exist. Finding the optimal one manually is mathematically impossible.</p>
                </div>
                <div class="problem-card">
                    <div class="problem-number">6mo</div>
                    <h3>Development Hell</h3>
                    <p>Average time from prototype to production for complex AI systems. Most never make it.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Solution Section -->
    <section class="solution-section">
        <div class="container">
            <span class="section-label">Our Solution</span>
            <h2 class="section-title">How <strong>Evolution</strong> Works</h2>
            <p class="section-description">
                Stop building agents manually. Let evolution discover them for you.
            </p>
            
            <div class="how-it-works">
                <div class="process-step" data-step="1">
                    <h3>Feed Examples</h3>
                    <p>Provide input-output examples of your task. No coding, no complex configurations—just show what success looks like.</p>
                </div>
                <div class="process-step" data-step="2">
                    <h3>Automatic Program Search</h3>
                    <p>Haldane explores millions of program variations, testing different reasoning patterns, tool combinations, and control flows.</p>
                </div>
                <div class="process-step" data-step="3">
                    <h3>Evolution & Optimization</h3>
                    <p>Programs that perform well survive and evolve. Poor performers are discarded. The system converges on optimal solutions.</p>
                </div>
            </div>

            <div class="discovery-visual">
                <p style="font-size: 1.25rem; margin-bottom: 1rem; font-weight: 600;">
                    Unlike tools that help you build agents, Haldane discovers them.
                </p>
                <p style="opacity: 0.9;">
                    Each iteration tests completely different approaches: chain-of-thought, multi-agent debate, self-correction loops, tool orchestration—until finding what actually works for YOUR specific problem.
                </p>
            </div>
        </div>
    </section>

    <!-- Big Bet Section -->
    <section class="bet-section">
        <span class="section-label">Our Thesis</span>
        <h2 class="section-title">The Big Bet</h2>
        <div class="bet-content">
            <p>
                We believe the industry is approaching AI development backwards.
            </p>
            <p style="margin-top: 1rem;">
                Everyone's trying to make better reasoning models or fine-tune on millions of examples. But <strong>what if the answer isn't in the weights at all?</strong>
            </p>
            <p style="margin-top: 1rem;">
                We're betting that <strong>discrete program search beats everything else</strong>. Instead of ephemeral reasoning that vanishes after each run, we create persistent programs that compound improvements. Instead of black boxes, we generate readable Python. Instead of starting from scratch, we evolve.
            </p>
            <p style="margin-top: 1rem;">
                This isn't incremental improvement. It's a fundamentally different paradigm—<strong>evolution in text space</strong> rather than weight space.
            </p>
            <div class="bet-signature">The Future is Discovered, Not Designed</div>
        </div>
    </section>

    <!-- Results Section -->
    <section class="results-section">
        <div class="container">
            <span class="section-label">Results</span>
            <h2 class="section-title">Real <strong>Performance</strong> Gains</h2>
            <p class="section-description">
                Haldane doesn't just work in theory. It's delivering breakthrough results across industries.
            </p>
            
            <div class="case-studies">
                <div class="case-study">
                    <div class="case-metric">94.2%</div>
                    <div class="case-metric-label">Accuracy Improvement</div>
                    <h4>Legal Discovery</h4>
                    <p>Discovered a novel multi-pass verification program that outperformed hand-tuned systems by finding edge cases humans missed.</p>
                </div>
                <div class="case-study">
                    <div class="case-metric">47x</div>
                    <div class="case-metric-label">Faster Development</div>
                    <h4>Financial Analysis</h4>
                    <p>2-week manual development reduced to 9 hours of automated discovery. The resulting program handles edge cases the team never considered.</p>
                </div>
                <div class="case-study">
                    <div class="case-metric">$2.1M</div>
                    <div class="case-metric-label">Cost Savings</div>
                    <h4>Healthcare Triage</h4>
                    <p>Evolved a program that routes patients 3x more accurately than rule-based systems, reducing misrouted cases by 89%.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- CTA Section -->
    <section class="cta-section" id="cta">
        <div class="container">
            <span class="section-label">Join the Evolution</span>
            <h2 class="section-title">Get <strong>Early Access</strong></h2>
            <p class="section-description">
                Limited spots available. Be among the first to discover what your AI can really do.
            </p>
            
            <form class="email-form">
                <input type="email" class="email-input" placeholder="your@email.com" required>
                <button type="submit" class="submit-button">Join</button>
            </form>
            <div class="success-message">✓ You're in! Check your email.</div>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-value">127</div>
                    <div class="stat-label">Companies Waiting</div>
                </div>
                <div class="stat">
                    <div class="stat-value">1.2M</div>
                    <div class="stat-label">Programs Tested</div>
                </div>
                <div class="stat">
                    <div class="stat-value">89%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
            </div>
        </div>
    </section>

    <footer>
        © 2024 Haldane - Evolution in Code Space
    </footer>

    <script>
        // Form submission
        document.querySelector('.email-form').addEventListener('submit', function(e) {
            e.preventDefault();
            document.querySelector('.email-form').style.display = 'none';
            document.querySelector('.success-message').style.display = 'block';
        });

        // Play button animation
        document.querySelector('.play-button').addEventListener('click', function() {
            alert('Video demo coming soon!');
        });

        // Smooth scroll
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });
    </script>

    <!-- Full Visualization Script (from viz.html) -->
    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const diagramCanvas = document.getElementById('diagramCanvas');
        const diagramCtx = diagramCanvas.getContext('2d');
        
        let iteration = 0;
        let nodes = [];
        let edges = [];
        let isPlaying = false;
        let animationId = null;
        let speed = 9.5;
        let nextNodeY = 50;
        let exploreRate = 100; // Start with pure exploration
        let exploitRate = 0;
        let bestFitness = 0;
        let bestNode = null;
        let currentDiagramIndex = -1;

        // Track occupied positions for better spacing
        let occupiedPositions = {};
        
        const X_SPACING = 56;
        const Y_SPACING = 40; // Increased spacing
        const MIN_Y_DISTANCE = 28; // Minimum distance between nodes at same X
        const NODE_RADIUS = 6;
        const LEFT_MARGIN = 30;
        const TOP_MARGIN = 50;

        // Function to draw 20 different system diagrams
        function drawSystemDiagram(index) {
            diagramCtx.clearRect(0, 0, diagramCanvas.width, diagramCanvas.height);
            
            const cx = diagramCanvas.width / 2;
            const cy = diagramCanvas.height / 2;
            
            diagramCtx.strokeStyle = '#000000';
            diagramCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            diagramCtx.lineWidth = 1.5;
            
            switch(index) {
                case 0: // Simple input-output
                    drawCircle(diagramCtx, 40, cy, 15);
                    drawArrow(diagramCtx, 55, cy, 145, cy);
                    drawCircle(diagramCtx, 160, cy, 15);
                    break;
                
                case 1: // Linear chain
                    drawCircle(diagramCtx, 30, cy, 12);
                    drawArrow(diagramCtx, 42, cy, 68, cy);
                    drawRect(diagramCtx, 70, cy-10, 20, 20);
                    drawArrow(diagramCtx, 90, cy, 110, cy);
                    drawCircle(diagramCtx, 170, cy, 12);
                    break;
                
                case 2: // Split path
                    drawCircle(diagramCtx, 30, cy, 12);
                    drawArrow(diagramCtx, 42, cy-10, 68, 30);
                    drawArrow(diagramCtx, 42, cy+10, 68, 70);
                    drawRect(diagramCtx, 70, 20, 20, 20);
                    drawRect(diagramCtx, 70, 60, 20, 20);
                    drawArrow(diagramCtx, 90, 30, 110, cy);
                    drawArrow(diagramCtx, 90, 70, 110, cy);
                    drawCircle(diagramCtx, 170, cy, 12);
                    break;
                
                case 3: // Triangle configuration
                    drawCircle(diagramCtx, cx, 25, 12);
                    drawCircle(diagramCtx, cx-30, 75, 12);
                    drawCircle(diagramCtx, cx+30, 75, 12);
                    drawLine(diagramCtx, cx, 37, cx-20, 63);
                    drawLine(diagramCtx, cx, 37, cx+20, 63);
                    drawLine(diagramCtx, cx-18, 75, cx+18, 75);
                    break;
                
                case 4: // Diamond pattern
                    drawDiamond(diagramCtx, cx, 25, 15);
                    drawRect(diagramCtx, cx-10, cy-10, 20, 20);
                    drawDiamond(diagramCtx, cx, 75, 15);
                    drawLine(diagramCtx, cx, 35, cx, cy-10);
                    drawLine(diagramCtx, cx, cy+10, cx, 65);
                    break;
                
                case 5: // Parallel processing
                    drawCircle(diagramCtx, 30, cy, 12);
                    drawRect(diagramCtx, 60, 25, 20, 15);
                    drawRect(diagramCtx, 60, 45, 20, 15);
                    drawRect(diagramCtx, 60, 65, 20, 15);
                    drawCircle(diagramCtx, 170, cy, 12);
                    for(let i = 0; i < 3; i++) {
                        drawArrow(diagramCtx, 42, cy, 60, 32 + i*20);
                        drawArrow(diagramCtx, 80, 32 + i*20, 158, cy);
                    }
                    break;
                
                case 6: // Feedback loop
                    drawCircle(diagramCtx, 50, cy, 15);
                    drawArrow(diagramCtx, 65, cy, 95, cy);
                    drawRect(diagramCtx, 95, cy-15, 30, 30);
                    drawArrow(diagramCtx, 125, cy, 155, cy);
                    drawCircle(diagramCtx, 170, cy, 15);
                    drawCurvedArrow(diagramCtx, 110, cy+15, 110, cy-15);
                    break;
                
                case 7: // Star configuration
                    drawCircle(diagramCtx, cx, cy, 15);
                    for(let i = 0; i < 5; i++) {
                        const angle = (i * 72 - 90) * Math.PI / 180;
                        const x = cx + Math.cos(angle) * 40;
                        const y = cy + Math.sin(angle) * 40;
                        drawCircle(diagramCtx, x, y, 8);
                        drawLine(diagramCtx, cx + Math.cos(angle) * 20, cy + Math.sin(angle) * 20,
                                x - Math.cos(angle) * 10, y - Math.sin(angle) * 10);
                    }
                    break;
                
                case 8: // Hierarchical tree
                    drawRect(diagramCtx, cx-10, 15, 20, 15);
                    drawRect(diagramCtx, cx-35, 45, 20, 15);
                    drawRect(diagramCtx, cx+15, 45, 20, 15);
                    drawCircle(diagramCtx, cx-40, 80, 8);
                    drawCircle(diagramCtx, cx-20, 80, 8);
                    drawCircle(diagramCtx, cx+20, 80, 8);
                    drawCircle(diagramCtx, cx+40, 80, 8);
                    drawLine(diagramCtx, cx, 30, cx-25, 45);
                    drawLine(diagramCtx, cx, 30, cx+25, 45);
                    drawLine(diagramCtx, cx-25, 60, cx-40, 72);
                    drawLine(diagramCtx, cx-25, 60, cx-20, 72);
                    drawLine(diagramCtx, cx+25, 60, cx+20, 72);
                    drawLine(diagramCtx, cx+25, 60, cx+40, 72);
                    break;
                
                case 9: // Mesh network
                    const meshNodes = [
                        {x: 50, y: 30}, {x: 150, y: 30},
                        {x: 50, y: 70}, {x: 150, y: 70},
                        {x: 100, y: 50}
                    ];
                    meshNodes.forEach(node => {
                        drawCircle(diagramCtx, node.x, node.y, 10);
                    });
                    for(let i = 0; i < meshNodes.length; i++) {
                        for(let j = i+1; j < meshNodes.length; j++) {
                            if(Math.random() > 0.3) {
                                drawLine(diagramCtx, meshNodes[i].x, meshNodes[i].y,
                                        meshNodes[j].x, meshNodes[j].y);
                            }
                        }
                    }
                    break;
                
                case 10: // Pipeline with branches
                    drawCircle(diagramCtx, 20, cy, 10);
                    drawArrow(diagramCtx, 30, cy, 50, cy);
                    drawDiamond(diagramCtx, 60, cy, 12);
                    drawArrow(diagramCtx, 70, cy-15, 90, 25);
                    drawArrow(diagramCtx, 70, cy+15, 90, 75);
                    drawRect(diagramCtx, 90, 15, 25, 20);
                    drawRect(diagramCtx, 90, 65, 25, 20);
                    drawArrow(diagramCtx, 115, 25, 135, cy);
                    drawArrow(diagramCtx, 115, 75, 135, cy);
                    drawCircle(diagramCtx, 145, cy, 10);
                    drawArrow(diagramCtx, 155, cy, 180, cy);
                    drawCircle(diagramCtx, 190, cy, 10);
                    break;
                
                case 11: // Circular flow
                    const circleRadius = 30;
                    for(let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = cx + Math.cos(angle) * circleRadius;
                        const y = cy + Math.sin(angle) * circleRadius;
                        if(i % 2 === 0) {
                            drawCircle(diagramCtx, x, y, 8);
                        } else {
                            drawRect(diagramCtx, x-8, y-8, 16, 16);
                        }
                        const nextAngle = ((i+1) * 60) * Math.PI / 180;
                        const nextX = cx + Math.cos(nextAngle) * circleRadius;
                        const nextY = cy + Math.sin(nextAngle) * circleRadius;
                        drawArrow(diagramCtx, x + Math.cos(nextAngle-angle)*8, 
                                 y + Math.sin(nextAngle-angle)*8,
                                 nextX - Math.cos(nextAngle-angle)*8, 
                                 nextY - Math.sin(nextAngle-angle)*8);
                    }
                    break;
                
                case 12: // Multi-layer
                    for(let layer = 0; layer < 3; layer++) {
                        const x = 40 + layer * 60;
                        for(let i = 0; i < 3; i++) {
                            const y = 25 + i * 25;
                            if(layer === 1) {
                                drawDiamond(diagramCtx, x, y, 10);
                            } else {
                                drawCircle(diagramCtx, x, y, 8);
                            }
                            if(layer < 2) {
                                for(let j = 0; j < 3; j++) {
                                    drawLine(diagramCtx, x+8, y, x+52, 25 + j * 25);
                                }
                            }
                        }
                    }
                    break;
                
                case 13: // Hub and spoke
                    drawRect(diagramCtx, cx-15, cy-15, 30, 30);
                    for(let i = 0; i < 8; i++) {
                        const angle = (i * 45) * Math.PI / 180;
                        const x = cx + Math.cos(angle) * 50;
                        const y = cy + Math.sin(angle) * 35;
                        drawCircle(diagramCtx, x, y, 6);
                        drawLine(diagramCtx, cx + Math.cos(angle) * 20, cy + Math.sin(angle) * 15,
                                x - Math.cos(angle) * 8, y - Math.sin(angle) * 8);
                    }
                    break;
                
                case 14: // Complex flow
                    drawCircle(diagramCtx, 20, 30, 8);
                    drawCircle(diagramCtx, 20, 70, 8);
                    drawRect(diagramCtx, 50, 40, 20, 20);
                    drawDiamond(diagramCtx, 90, 50, 12);
                    drawRect(diagramCtx, 120, 25, 20, 15);
                    drawRect(diagramCtx, 120, 60, 20, 15);
                    drawCircle(diagramCtx, 170, 50, 10);
                    drawArrow(diagramCtx, 28, 30, 50, 45);
                    drawArrow(diagramCtx, 28, 70, 50, 55);
                    drawArrow(diagramCtx, 70, 50, 78, 50);
                    drawArrow(diagramCtx, 102, 45, 120, 32);
                    drawArrow(diagramCtx, 102, 55, 120, 68);
                    drawArrow(diagramCtx, 140, 32, 160, 45);
                    drawArrow(diagramCtx, 140, 68, 160, 55);
                    break;
                
                case 15: // Grid layout
                    for(let i = 0; i < 4; i++) {
                        for(let j = 0; j < 3; j++) {
                            const x = 35 + i * 45;
                            const y = 25 + j * 25;
                            if((i + j) % 2 === 0) {
                                drawCircle(diagramCtx, x, y, 6);
                            } else {
                                drawRect(diagramCtx, x-6, y-6, 12, 12);
                            }
                            if(i < 3) drawLine(diagramCtx, x+6, y, x+39, y);
                            if(j < 2) drawLine(diagramCtx, x, y+6, x, y+19);
                        }
                    }
                    break;
                
                case 16: // Recursive structure
                    function drawRecursive(x, y, size, depth) {
                        if(depth === 0) return;
                        drawRect(diagramCtx, x-size/2, y-size/2, size, size);
                        if(depth > 1) {
                            drawRecursive(x-size, y, size/1.5, depth-1);
                            drawRecursive(x+size, y, size/1.5, depth-1);
                        }
                    }
                    drawRecursive(cx, cy, 20, 3);
                    break;
                
                case 17: // Converging paths
                    for(let i = 0; i < 4; i++) {
                        const y = 20 + i * 20;
                        drawCircle(diagramCtx, 30, y, 6);
                        drawArrow(diagramCtx, 36, y, 80, cy-10 + i*5);
                    }
                    drawDiamond(diagramCtx, 90, cy, 15);
                    drawArrow(diagramCtx, 105, cy, 160, cy);
                    drawCircle(diagramCtx, 170, cy, 10);
                    break;
                
                case 18: // Nested system
            diagramCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                    drawRect(diagramCtx, 30, 20, 140, 60);
            diagramCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                    drawRect(diagramCtx, 50, 35, 100, 30);
            diagramCtx.strokeStyle = '#000000';
                    drawCircle(diagramCtx, 75, 50, 8);
                    drawDiamond(diagramCtx, 100, 50, 10);
                    drawCircle(diagramCtx, 125, 50, 8);
                    drawLine(diagramCtx, 83, 50, 90, 50);
                    drawLine(diagramCtx, 110, 50, 117, 50);
                    break;
                
                case 19: // Ultimate complex
                    // Central hub
                    drawRect(diagramCtx, cx-12, cy-12, 24, 24);
                    // Inner ring
                    for(let i = 0; i < 6; i++) {
                        const angle = (i * 60) * Math.PI / 180;
                        const x = cx + Math.cos(angle) * 25;
                        const y = cy + Math.sin(angle) * 25;
                        drawDiamond(diagramCtx, x, y, 8);
                        drawLine(diagramCtx, cx + Math.cos(angle) * 15, cy + Math.sin(angle) * 15,
                                x - Math.cos(angle) * 6, y - Math.sin(angle) * 6);
                    }
                    // Outer ring
                    for(let i = 0; i < 8; i++) {
                        const angle = (i * 45 + 22.5) * Math.PI / 180;
                        const x = cx + Math.cos(angle) * 45;
                        const y = cy + Math.sin(angle) * 35;
                        drawCircle(diagramCtx, x, y, 5);
                        const innerAngle = Math.floor(i * 0.75) * 60 * Math.PI / 180;
                        const innerX = cx + Math.cos(innerAngle) * 25;
                        const innerY = cy + Math.sin(innerAngle) * 25;
                        drawLine(diagramCtx, innerX + Math.cos(angle) * 8, 
                                innerY + Math.sin(angle) * 8,
                                x - Math.cos(angle) * 5, 
                                y - Math.sin(angle) * 5);
                    }
                    break;
            }
        }

        // Helper functions for drawing shapes
        function drawCircle(ctx, x, y, r) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }

        function drawRect(ctx, x, y, w, h) {
            ctx.fillRect(x, y, w, h);
            ctx.strokeRect(x, y, w, h);
        }

        function drawDiamond(ctx, x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size, y);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x - size, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function drawLine(ctx, x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawArrow(ctx, x1, y1, x2, y2) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Arrowhead
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 8 * Math.cos(angle - Math.PI/6), y2 - 8 * Math.sin(angle - Math.PI/6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 8 * Math.cos(angle + Math.PI/6), y2 - 8 * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }

        function drawCurvedArrow(ctx, x1, y1, x2, y2) {
            const cp1x = x1 - 30;
            const cp1y = (y1 + y2) / 2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(cp1x, cp1y, x2, y2);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(y2 - cp1y, x2 - cp1x);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 8 * Math.cos(angle - Math.PI/6), y2 - 8 * Math.sin(angle - Math.PI/6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 8 * Math.cos(angle + Math.PI/6), y2 - 8 * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }

        class Node {
            constructor(id, x, y, fitness, parent = null, type = 'explore') {
                this.id = id;
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.fitness = fitness;
                this.parent = parent;
                this.type = type; // 'explore', 'exploit', 'refine'
                this.children = [];
                this.appearAnimation = 0;
                this.pulseAnimation = 0;
                this.isElite = false;
                this.isBest = false;
                this.childrenCount = 0; // Track number of children for spacing
                this.diagramIndex = Math.floor(fitness * 19); // Map fitness to diagram
            }

            update() {
                // Smooth position transitions
                this.x += (this.targetX - this.x) * 0.1;
                this.y += (this.targetY - this.y) * 0.1;

                // Update animations
                if (this.appearAnimation < 1) {
                    this.appearAnimation += 0.05;
                }
                if (this.pulseAnimation > 0) {
                    this.pulseAnimation -= 0.02;
                }
            }

            draw() {
                const alpha = Math.min(1, this.appearAnimation);
                const radius = NODE_RADIUS + (this.pulseAnimation * 12);

                // Draw pulse if animating
                if (this.pulseAnimation > 0) {
                    ctx.fillStyle = `rgba(0, 255, 136, ${this.pulseAnimation * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, radius + 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Special highlight for best node
                if (this.isBest) {
                    ctx.shadowColor = '#FF1744';
                    ctx.shadowBlur = 16;
                    ctx.fillStyle = 'rgba(255, 23, 68, 0.15)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, radius + 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Node color based on type and fitness
                if (this.type === 'explore' && this.appearAnimation < 0.5) {
                    ctx.fillStyle = `rgba(255, 109, 0, ${alpha})`; // k-orange
                } else if (this.isElite) {
                    ctx.fillStyle = `rgba(41, 121, 255, ${alpha})`; // k-blue
                } else {
                    const brightness = Math.max(0.2, this.fitness);
                    ctx.fillStyle = `rgba(0, 0, 0, ${brightness * alpha})`;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.strokeStyle = this.isBest ? '#FF1744' : `rgba(0, 0, 0, ${0.3 * alpha})`;
                ctx.lineWidth = this.isBest ? 2 : 1;
                ctx.stroke();
            }
        }

        function findAvailableY(x, preferredY) {
            // Find an available Y position at the given X coordinate
            const xKey = Math.round(x);
            if (!occupiedPositions[xKey]) {
                occupiedPositions[xKey] = [];
            }

            let bestY = preferredY;
            let minDistance = Infinity;

            // Find the closest available position
            const occupied = occupiedPositions[xKey].sort((a, b) => a - b);
            
            if (occupied.length === 0) {
                occupiedPositions[xKey].push(preferredY);
                return preferredY;
            }

            // Try to place at preferred position if far enough from others
            let canPlaceAtPreferred = true;
            for (let y of occupied) {
                if (Math.abs(y - preferredY) < MIN_Y_DISTANCE) {
                    canPlaceAtPreferred = false;
                    break;
                }
            }

            if (canPlaceAtPreferred) {
                occupiedPositions[xKey].push(preferredY);
                return preferredY;
            }

            // Find gaps in occupied positions
            const gaps = [];
            for (let i = 0; i < occupied.length - 1; i++) {
                if (occupied[i + 1] - occupied[i] >= MIN_Y_DISTANCE * 2) {
                    gaps.push((occupied[i] + occupied[i + 1]) / 2);
                }
            }

            // Add positions above and below
            gaps.push(occupied[0] - MIN_Y_DISTANCE);
            gaps.push(occupied[occupied.length - 1] + MIN_Y_DISTANCE);

            // Find closest gap to preferred position
            for (let gap of gaps) {
                const distance = Math.abs(gap - preferredY);
                if (distance < minDistance) {
                    minDistance = distance;
                    bestY = gap;
                }
            }

            occupiedPositions[xKey].push(bestY);
            return bestY;
        }

        function createExplorationNode() {
            // Lower initial fitness, harder to improve
            const fitness = 0.1 + Math.random() * 0.15;
            const x = LEFT_MARGIN;
            const y = nextNodeY;
            nextNodeY += Y_SPACING;
            
            const node = new Node(nodes.length, x, y, fitness, null, 'explore');
            node.pulseAnimation = 1;
            
            // Register position
            if (!occupiedPositions[x]) occupiedPositions[x] = [];
            occupiedPositions[x].push(y);
            
            nodes.push(node);
            checkForNewBest(node);
            return node;
        }

        function createExploitationNode(parent) {
            // Smaller improvements with diminishing returns
            const improvementFactor = Math.max(0.01, (1 - parent.fitness) * 0.3); // Smaller as fitness increases
            const noise = (Math.random() - 0.5) * 0.1;
            const fitness = Math.min(0.98, parent.fitness + improvementFactor + noise);
            
            const x = parent.x + X_SPACING;
            
            // Calculate Y position with better spacing
            const baseY = parent.y;
            const offset = (parent.childrenCount - Math.floor(parent.children.length / 2)) * Y_SPACING;
            const preferredY = baseY + offset;
            
            const y = findAvailableY(x, preferredY);
            
            parent.childrenCount++;
            
            const node = new Node(nodes.length, x, y, fitness, parent, 'exploit');
            parent.children.push(node);
            edges.push({ from: parent, to: node });
            node.pulseAnimation = 1;
            nodes.push(node);
            checkForNewBest(node);
            return node;
        }

        function createRefinementNode(parent1, parent2) {
            // Refinement with diminishing returns
            const avgFitness = (parent1.fitness + parent2.fitness) / 2;
            const improvementFactor = Math.max(0.01, (1 - avgFitness) * 0.2);
            const fitness = Math.min(0.98, avgFitness + improvementFactor + Math.random() * 0.05);
            
            const x = Math.max(parent1.x, parent2.x) + X_SPACING;
            const preferredY = (parent1.y + parent2.y) / 2;
            const y = findAvailableY(x, preferredY);
            
            const node = new Node(nodes.length, x, y, fitness, parent1, 'refine');
            parent1.children.push(node);
            parent1.childrenCount++;
            
            edges.push({ from: parent1, to: node });
            edges.push({ from: parent2, to: node, secondary: true });
            node.pulseAnimation = 1;
            nodes.push(node);
            checkForNewBest(node);
            return node;
        }

        function checkForNewBest(node) {
            if (node.fitness > bestFitness) {
                bestFitness = node.fitness;
                
                // Update best node marking
                nodes.forEach(n => n.isBest = false);
                node.isBest = true;
                bestNode = node;
                
                // Update diagram overlay
                updateDiagramOverlay(node);
            }
        }

        function updateDiagramOverlay(node) {
            const overlay = document.getElementById('diagramOverlay');
            const fitnessDisplay = document.getElementById('diagramFitness');
            
            overlay.classList.add('visible');
            fitnessDisplay.textContent = node.fitness.toFixed(3);
            
            // Map fitness to one of 20 diagram indices
            const newIndex = Math.min(19, Math.floor(node.fitness * 20));
            if (newIndex !== currentDiagramIndex) {
                currentDiagramIndex = newIndex;
                drawSystemDiagram(currentDiagramIndex);
            }
        }

        function evolveTree() {
            iteration++;
            
            // Mandatory exploration for first 8 iterations
            if (iteration <= 8) {
                exploreRate = 100;
                exploitRate = 0;
            } else if (iteration <= 15) {
                exploreRate = 60;
                exploitRate = 40;
            } else if (iteration <= 25) {
                exploreRate = 35;
                exploitRate = 65;
            } else if (iteration <= 40) {
                exploreRate = 20;
                exploitRate = 80;
            } else {
                exploreRate = 10;
                exploitRate = 90;
            }

            // Update strategy bars
            document.getElementById('exploreBar').style.width = exploreRate + '%';
            document.getElementById('exploitBar').style.width = exploitRate + '%';

            // Decide action based on rates
            const roll = Math.random() * 100;
            
            if (roll < exploreRate || nodes.length === 0) {
                // Exploration: new approach
                createExplorationNode();
            } else {
                // Exploitation: improve on existing
                // Sort by fitness but also consider recency to give newer nodes a chance
                const scoredNodes = nodes.map((node, idx) => ({
                    node: node,
                    score: node.fitness * 0.8 + (idx / nodes.length) * 0.2 // 80% fitness, 20% recency
                }));
                
                const sorted = scoredNodes.sort((a, b) => b.score - a.score);
                const elite = sorted.slice(0, Math.max(5, Math.floor(nodes.length * 0.2))).map(s => s.node);
                
                // Mark elite nodes
                nodes.forEach(n => n.isElite = false);
                elite.forEach(n => n.isElite = true);
                
                // Increased probability of refinement/combination for broader tree
                if (Math.random() < 0.45 && elite.length > 1) { // Increased from 0.3 to 0.45
                    // Refinement: combine two good solutions
                    const parent1 = elite[Math.floor(Math.random() * elite.length)];
                    const parent2 = elite[Math.floor(Math.random() * elite.length)];
                    if (parent1 !== parent2) {
                        createRefinementNode(parent1, parent2);
                    }
                } else {
                    // Regular exploitation
                    const parent = elite[Math.floor(Math.random() * elite.length)];
                    createExploitationNode(parent);
                }
            }

            updateStats();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            edges.forEach(edge => {
                const alpha = Math.min(edge.from.appearAnimation, edge.to.appearAnimation);
                
                if (edge.secondary) {
                    ctx.strokeStyle = `rgba(41, 121, 255, ${0.25 * alpha})`;
                    ctx.setLineDash([5, 5]);
                } else {
                    const brightness = Math.max(0.2, edge.to.fitness);
                    ctx.strokeStyle = `rgba(0, 0, 0, ${brightness * 0.4 * alpha})`;
                    ctx.setLineDash([]);
                }
                
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(edge.from.x, edge.from.y);
                ctx.lineTo(edge.to.x, edge.to.y);
                ctx.stroke();
            });
            
            ctx.setLineDash([]);
            
            // Draw connection to diagram overlay if we have a best node
            if (bestNode && document.getElementById('diagramOverlay').classList.contains('visible')) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(bestNode.x, bestNode.y);
                ctx.lineTo(canvas.width - 230, 70);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Update and draw nodes
            nodes.forEach(node => {
                node.update();
                node.draw();
            });
        }

        function updateStats() {
            document.getElementById('iterationCount').textContent = iteration;
            document.getElementById('bestFitness').textContent = bestFitness.toFixed(3);
            document.getElementById('fitnessBar').style.width = `${bestFitness * 100}%`;
        }

        // Animation loop that always runs for smooth animations
        function animate() {
            draw();
            
            // Always keep animating for pulse effects
            animationId = requestAnimationFrame(animate);
        }

        let evolutionInterval;
        function startEvolution() {
            if (evolutionInterval) clearInterval(evolutionInterval);
            const delay = 1100 - (speed * 100); // Speed from 1-10 maps to 1000ms - 100ms
            evolutionInterval = setInterval(() => {
                if (isPlaying && iteration < 60) { // Max 60 iterations
                    evolveTree();
                } else if (iteration >= 60) {
                    stopEvolution();
                }
            }, delay);
        }

        function stopEvolution() {
            if (evolutionInterval) {
                clearInterval(evolutionInterval);
                evolutionInterval = null;
            }
            isPlaying = false;
            document.getElementById('playBtn').textContent = 'PLAY';
        }

        // Controls
        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            
            if (isPlaying) {
                document.getElementById('playBtn').textContent = 'PAUSE';
                startEvolution();
            } else {
                document.getElementById('playBtn').textContent = 'PLAY';
                stopEvolution();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            stopEvolution();
            
            iteration = 0;
            nodes = [];
            edges = [];
            nextNodeY = TOP_MARGIN;
            bestFitness = 0;
            bestNode = null;
            currentDiagramIndex = -1;
            exploreRate = 100;
            exploitRate = 0;
            occupiedPositions = {};
            
            document.getElementById('exploreBar').style.width = '100%';
            document.getElementById('exploitBar').style.width = '0%';
            document.getElementById('diagramOverlay').classList.remove('visible');
            
            updateStats();
            draw();
        });

        // speed is fixed via code; no user control

        // Initialize and start animation loop
        updateStats();
        animate(); // Always animating for smooth effects

        // Autoplay when visualization enters viewport
        const vizSection = document.getElementById('treeCanvas');
        if ('IntersectionObserver' in window && vizSection) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (!isPlaying) {
                            isPlaying = true;
                            const playBtn = document.getElementById('playBtn');
                            if (playBtn) playBtn.textContent = 'PAUSE';
                            startEvolution();
                        }
                    }
                });
            }, { threshold: 0.3 });
            observer.observe(vizSection);
        } else {
            // Fallback: start immediately
            isPlaying = true;
            const playBtn = document.getElementById('playBtn');
            if (playBtn) playBtn.textContent = 'PAUSE';
            startEvolution();
        }
    </script>
</body>
</html>